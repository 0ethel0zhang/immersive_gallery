# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Commands

- **Dev server:** `npm run dev` (Vite, serves on all interfaces via `--host`)
- **Build:** `npm run build` (runs `tsc -b` then `vite build`)
- **Type check:** `npm run check:types` (uses `tsconfig.app.json`)
- **Lint:** `npm run check:biome` (Biome, errors only)
- **Both checks:** `npm run check`
- **Format:** `npm run format` (Biome check --write --unsafe)
- **Preview prod build:** `npm run preview`

No test framework is configured.

## Path Aliases

`~/` maps to the project root (configured in both `vite.config.ts` and `tsconfig.app.json`). All imports use this alias, e.g. `import { clamp } from "~/src/utils"`.

## Code Style

- **React imports:** Must use `import * as React from "react"` — named/default imports from "react" are a Biome lint error.
- **Formatter:** Biome with 130-char line width, 2-space indent, double quotes, semicolons, ES5 trailing commas.
- **React Compiler** is enabled via `babel-plugin-react-compiler` in the Vite config.
- **Strict TypeScript** with `noUnusedLocals`, `noUnusedParameters`, `verbatimModuleSyntax`, `erasableSyntaxOnly`.
- **npm config:** `save-exact=true` and `engine-strict=true` (pinned deps). Node 22.14.0 (`.nvmrc`).

## Key Patterns

- **Ref-heavy animation state** — All mutable per-frame state lives in `React.useRef` (velocities, positions, drag state, opacity), not `useState`. React state is only used for things that trigger re-renders (chunk list, texture readiness).
- **Seeded determinism** — Chunk plane positions are derived from `hashString(chunkCoords)` + `seededRandom`, so the same chunk coordinates always produce the same layout.
- **LRU plane cache** — Generated chunk planes are cached (256 entries max) in a `Map` using delete-and-reinsert for LRU ordering.
- **Texture callback coalescence** — Multiple planes requesting the same image share one load. Callbacks are collected in a `Set` and fired when the texture loads.
- **Throttled chunk updates** — Chunk recalculation is throttled based on zoom speed (100ms normal, 400–500ms while zooming fast) to avoid thrashing during rapid camera movement.
- **Lazy loading** — `InfiniteCanvas` wraps the heavy R3F scene in `React.lazy` + `Suspense` so the main bundle stays small.

## Architecture

This is an infinite 3D canvas for exploring artwork images, built with React 19 + Three.js + React Three Fiber + Vite.

### Core rendering pipeline

**Chunk-based infinite grid** (`src/infinite-canvas/`): The 3D space is divided into chunks of `CHUNK_SIZE` (110 units). As the camera moves, `SceneController` computes which chunk the camera is in and generates surrounding chunks within `RENDER_DISTANCE + CHUNK_FADE_MARGIN`. Each `Chunk` generates 5 randomly-placed planes using seeded randomness (`hashString` + `seededRandom` in `src/utils.ts`) for deterministic layout. Plane generation is cached with an LRU cache (256 entries) in `utils.ts`.

**Texture management** (`texture-manager.ts`): Global singleton `TextureLoader` with a `Map`-based cache. Textures load on-demand with callback coalescence — multiple planes requesting the same texture share one load operation.

**Fade system** (`MediaPlane` in `scene.tsx`): Each plane computes opacity per-frame based on two factors: grid distance fade (chunk distance from camera) and depth fade (Z-distance from camera). Planes below `INVIS_THRESHOLD` (0.01) are hidden entirely. Every other frame is skipped for invisible planes as an optimization.

### Input handling

All in `SceneController`: mouse drag pans X/Y, scroll wheel zooms Z-axis, touch drag/pinch supported, WASD + QE keyboard navigation. Physics uses velocity with lerp smoothing and decay. Mouse position creates a subtle parallax drift effect (disabled on touch). Chunk updates are throttled based on zoom speed.

### Data flow

`App` loads artwork metadata from `src/artworks/manifest.json` (static JSON array of `{url, width, height}`). Images are in `public/artworks/`. The `PageLoader` shows a progress bar driven by R3F's `useProgress` hook with lerped visual animation.

### Component hierarchy

`App` → `Frame` (header/nav overlay) + `PageLoader` (loading screen) + `InfiniteCanvas` (lazy-loaded via `React.lazy`) → `InfiniteCanvasScene` (R3F `Canvas` + fog + keyboard controls) → `SceneController` (camera/input/chunk management) → `Chunk[]` → `MediaPlane[]`

Architecture Overview

The app uses CopilotKit with an Anthropic adapter (Claude Sonnet) to give users a natural-language chat interface for controlling the 3D
gallery. The system has three layers:

1. Server — server/index.ts

An Express server hosts the CopilotKit runtime at /api/copilotkit. It uses AnthropicAdapter with claude-sonnet-4-20250514 and provides a
system prompt telling Claude it's a gallery assistant that can modify colors, layout, frames, and overlays.

2. Chat UI — src/chat/index.tsx

A ChatPanel component (toggle button with sparkle icon) uses useCopilotChat to send user messages to the CopilotKit runtime and display
responses. This is the user-facing interface to Claude.

3. Actions & Readables — src/copilot/

Readables (readables.tsx) expose app state to Claude so it can reason about what's currently configured:

- Artwork metadata (titles, artists, years — first 20 items)
- Current layout parameters (mode, density, size range, spacing, depth)
- Currently applied visual effects (frames, overlays, filters, depth)

Actions (actions.tsx) register 7 useCopilotAction hooks that Claude can invoke via tool calls:

┌───────────────────┬────────────────────────────────────────────────────────────────────────────────────────────┐
│ Action │ What it does │
├───────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
│ changeSceneColors │ Sets background and fog color of the 3D scene │
├───────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
│ modifyLayout │ Changes artwork arrangement — density, size range, spacing, grid/random mode, depth spread │
├───────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
│ addFrame │ Adds decorative border frames (simple/ornate/double) to all artworks │
├───────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
│ addOverlay │ Adds particle effects (sparkles/stars/dust) around artworks │
├───────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
│ applyFilter │ Applies GLSL visual filters (grayscale, sepia, warm, cool, vintage, etc.) │
├───────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
│ addDepth │ Gives artworks 3D thickness with visible side edges │
├───────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
│ clearAllEffects │ Resets everything to defaults │
└───────────────────┴────────────────────────────────────────────────────────────────────────────────────────────┘

4. Effects System — src/copilot/effects-store.ts + effects-context.tsx

The effects state (frames, overlays, filters, depths) lives in a ref-based store with a manual revision counter. When Claude triggers an
action, the handler mutates the store and calls notify(), which bumps the revision and triggers a React re-render. The scene components
(FrameDecoration, OverlayEffect, DepthEffect, and filter shaders in scene.tsx) read from this store via useEffects() and apply the visual
changes in the Three.js scene.

Data Flow Summary

User types in ChatPanel
→ CopilotKit sends to server (Claude Sonnet)
→ Claude reads Readables (current state) + picks an Action
→ Action handler mutates EffectsState / calls setSceneColors / setLayoutParams
→ React re-renders → Three.js scene updates visually
→ Claude's text response appears in ChatPanel

So Claude acts as a natural-language controller — it interprets what the user wants ("make it look like a museum", "add gold frames",
"make it moody and dark"), maps that to the appropriate action(s) with suitable parameters, and executes them against the app's state.
